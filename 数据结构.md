# 绪论

### 数据结构三要素

1. 逻辑结构
2. 存储（物理）结构
   - 顺序存储
   - 链式存储
   - 散列存储
   - 索引存储
3. 数据运算

### 数据类型和抽象数据类型

原子类型

结构类型

**探讨数据结构的思路**

1. 确定逻辑结构（数据间的关系）
2. 定义数据运算（根据需求定义对逻辑结构的运算方式）
3. 确定存储结构





## 算法

### 算法五个性质

1. 有穷性（算法有穷，程序可无穷）
2. 确定性（相同输入相同输出）
3. 可行性（可通过基本运算执行有穷次实现）
4. 零到多个输入
5. 一到多个输出

#### 好算法的要素

1. 正确性

2. 可读性

3. 健壮性

4. 低时间复杂度、低空间复杂度

   

### 时间复杂度 T(n)

常对幂指阶

主要考虑**最坏**和**平均**时间复杂度

### 空间复杂度 S(n)





# 线性表 L

**定义**：$相同数据类型的\ n\ 个数据元素的有限序列，n为表长，n=0\ 时称为空表$

线性表基本操作：**当需要对数据的修改带回来时，需要传引用类型&**

## 顺序表

使用顺序存储的方式实现的线性表

**顺序存储**：将逻辑上相邻的数据元素存储在物理位置也相邻的存储单元

**代码实现**：

```c
#静态分配
#define MaxSize 50
typedef struct{
  ElemType data[MaxSize];
  int length;
}Sqlist;

#动态分配
#define INIT_SIZE 10
typedef struct
{
    int *data;
    int maxSize;
    int length;
} SeqList;
```



**实现**：

1. 静态分配

   初始化时必须将顺序表长度设为0（L.length=0）

2. 动态分配：

   - L.data = (ElemType *) malloc (sizeof (ElemType) * type)
   - malloc ()、Free ()

**特点**：

1. 随机访问 （可在O (1) 时间内找到第 i 个元素）
2. 存储密度高
3. 扩展长度不便
4. 插入删除不便

**基本操作**：

|          | 最好 | 最坏 | 平均 |
| :------: | :--: | :--: | :--: |
|   插入   | O(1) | O(n) | O(n) |
|   删除   | O(1) | O(n) | O(n) |
| 按位查找 |      |      | O(1) |
| 按值查找 | O(1) | O(n) | O(n) |



## 单链表

使用链式存储实现了线性结构

各节点先后关系用一个指针解决

**代码实现**：

```c
typedef struct LNode {
  ElemType * data;
  struct LNode * next;
}LNode,*LinkList;
```



**实现方式**：

|          |     带头节点      | 不带头节点 |
| :------: | :---------------: | :--------: |
| 空表判断 | L -> next == null | L == null  |

